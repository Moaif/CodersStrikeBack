#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "cmath"

using namespace std;

#define PI 3.14159265

const int CHECKPOINT_RADIUS = 600;
const int POD_RADIUS = 400;
const int NUM_PODS_PER_PLAYER =2;
const int NUM_PLAYERS = 2;
const float SIMULATION_TICK_INTERVAL = 0.01f;

const int MAX_MOVES_SIM = 5;

class Point{
    public:
    float x;
    float y;

    Point(float x, float y);
    float Distance2(const Point& p)const;
    float Distance(const Point& p)const;
    Point Closest(const Point& a, const Point& b)const;
};

class Unit: public Point{
    public:
    int id;
    float r;
    float vx;
    float vy;

    Unit(float x, float y,int id, float r, float vx, float vy);
    class Collision* CheckCollision(Unit& u);
    virtual void Bounce(Unit& u);
};

class Checkpoint: public Unit{
    public:
    Checkpoint(float x, float y,int id);
    virtual void Bounce(Unit& u)override;
};

class Pod: public Unit{
    public:    
    float angle;
    int nextCheckpointId;
    int checkpointsElapsed;
    int timeout;
    int turnsSinceLastShield;

    Pod(int id);
    float GetAngle(const Point& p)const;
    float DiffAngle(const Point& p)const;
    void Rotate(const Point& p);
    void Boost(int thrust);
    void Move(float t);
    void EndTurnCalculations();
    void Play(const Point& p, int thrust);
    virtual void Bounce(Unit& u) override;
    void BounceWithCheckpoint(Checkpoint& c);
    void Output(const class Move& move) const;

    void UpdateValues(float x, float y, float vx, float vy, float angle, int nextCheckPointId);
};

class Collision{
    public:
    Unit& a;
    Unit& b;

    Collision(Unit& a, Unit& b);
};

class Move{
    public:
    float angle;
    int thrust;

    Move(float angle, int thrust);
    void Mutate(float amplitude);
};


class Solution{
    public:
    Move* moves1[MAX_MOVES_SIM];
    Move* moves2[MAX_MOVES_SIM];

    void Mutate(float amplitude);
};


Point::Point(float x, float y): x(x), y(y){}

float Point::Distance2(const Point& p)const{
    return (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y);
}

float Point::Distance(const Point& p)const{
    return sqrt(Distance2(p));
}

Point Point::Closest(const Point& a, const Point& b)const{
    float da = b.y - a.y;
    float db = a.x - b.x;
    float c1 = da*a.x + db*a.y;
    float c2 = -db*x + da*y;
    float det = da*da + db*db;
    float cx = 0;
    float cy = 0;

    if (det != 0) {
        cx = (da*c1 - db*c2) / det;
        cy = (da*c2 + db*c1) / det;
    } else {
        // The point is already on the line
        cx = x;
        cy = y;
    }

    return Point(cx, cy);
} 

Unit::Unit(float x, float y,int id, float r, float vx, float vy):Point(x, y), id(id), r(r), vx(vx), vy(vy){}

Collision* Unit::CheckCollision(Unit& u){
    // Square of the distance
    float dist = Distance2(u);

    // Sum of the radii squared
    float sr = (r + u.r)*(r + u.r);

    // We take everything squared to avoid calling sqrt uselessly. It is better for performances
    if (dist < sr) {
        // Objects are already touching each other. We have an immediate collision.
        return new Collision(*this, u);
    }

    return nullptr;
}

//Will be overriden on children
void Unit::Bounce(Unit& u){}

Checkpoint::Checkpoint(float x, float y, int id): Unit(x,y,id,CHECKPOINT_RADIUS,0,0){}

void Checkpoint::Bounce(Unit& u){}

Pod::Pod(int id):Unit(0,0,id,POD_RADIUS,0,0),angle(0.0f),nextCheckpointId(0),timeout(100),turnsSinceLastShield(4){}

float Pod::GetAngle(const Point& p)const{
    float d = Distance(p);
    float dx = (p.x - x) / d;
    float dy = (p.y - y) / d;

    // Simple trigonometry. We multiply by 180.0 / PI to convert radiants to degrees.
    float a = acos(dx) * 180.0 / PI;

    // If the point I want is below me, I have to shift the angle for it to be correct
    if (dy < 0) {
        a = 360.0 - a;
    }

    return a;
}

float Pod::DiffAngle(const Point& p)const{
    float a = GetAngle(p);

    // To know whether we should turn clockwise or not we look at the two ways and keep the smallest
    // The ternary operators replace the use of a modulo operator which would be slower
    float right = angle <= a ? a - angle : 360.0 - angle + a;
    float left = angle >= a ? angle - a : angle + 360.0 - a;

    if (right < left) {
        return right;
    } else {
        // We return a negative angle if we must rotate to left
        return -left;
    }
}

void Pod::Rotate(const Point& p){
    float a = DiffAngle(p);

    // Can't turn by more than 18Â° in one turn
    if (a > 18.0) {
        a = 18.0;
    } else if (a < -18.0) {
        a = -18.0;
    }

    angle += a;

    // The % operator is slow. If we can avoid it, it's better.
    if (angle >= 360.0) {
        angle = angle - 360.0;
    } else if (angle < 0.0) {
        angle += 360.0;
    }
}

void Pod::Boost(int thrust){
    // Don't forget that a pod which has activated its shield cannot accelerate for 3 turns
    if (turnsSinceLastShield <= 3) {
        return;
    }

    // Conversion of the angle to radiants
    float ra = angle * PI / 180.0;

    // Trigonometry
    vx += cos(ra) * thrust;
    vy += sin(ra) * thrust;
}

void Pod::Move(float t){
    x += vx * t;
    y += vy * t;
}

void Pod::EndTurnCalculations(){
    x = round(x);
    y = round(y);
    vx = static_cast<int>(vx * 0.85);//Truncate
    vy = static_cast<int>(vy * 0.85);//Truncate

    //This can be a problem if the program would be infinite, but as it only works for a small number of turns, it would never get overflowed
    ++turnsSinceLastShield;

    // Don't forget that the timeout goes down by 1 each turn. It is reset to 100 when you pass a checkpoint
    timeout -= 1;
}

void Pod::Play(const Point& p, int thrust){
    Rotate(p);
    Boost(thrust);
    Move(1.0);
    EndTurnCalculations();
}


Point ComputeImpulse(float vx1, float vy1, float vx2, float vy2, float x1, float y1, float x2, float y2, float m1, float m2){
    
    float mcoeff = 2.0f*m2/(m1+m2);

    float dvx = vx1 - vx2;
    float dvy = vy1 - vy2;
    float dx = x1 - x2;
    float dy = y1 - y2;
    float dotProd = dvx * dx + dvy * dy;
    float squareProd = dx * dx + dy * dy;

    float impulseX = mcoeff * (dotProd/squareProd)*dx;
    float impulseY = mcoeff * (dotProd/squareProd)*dy;

    return Point(impulseX,impulseY);
}

void Pod::Bounce(Unit& u){
    if (Checkpoint* c = dynamic_cast<Checkpoint*>(&u)) {  
        // Collision with a checkpoint
        BounceWithCheckpoint(*c);
    } else if(Pod* pod = dynamic_cast<Pod*>(&u)) {
        // If a pod has its shield active its mass is 10 otherwise it's 1
        float m1 = turnsSinceLastShield == 0 ? 10 : 1;
        float m2 = pod->turnsSinceLastShield == 0 ? 10 : 1;
        
        Point dv1 = ComputeImpulse(vx, vy, pod->vx, pod->vy, x, y, pod->x, pod->y, m1, m2);
        Point dv2 = ComputeImpulse(pod->vx, pod->vy, vx, vy, pod->x, pod->y, x, y, m2, m1);

        float impulse1 = sqrt(dv1.x * dv1.x + dv1.y * dv1.y);
        float impulse2 = sqrt(dv2.x * dv2.x + dv2.y * dv2.y);

        if(impulse1 < 120){
            dv1.x = dv1.x * 120/impulse1;
            dv1.y = dv1.y * 120/impulse1;
        }
        if(impulse2 < 120){
            dv2.x = dv2.x * 120/impulse2;
            dv2.y = dv2.y * 120/impulse2;
        }

        vx -= dv1.x;
        vy -= dv1.y;
        pod->vx -= dv2.x;
        pod->vy -= dv2.y;
    }
}

void Pod::BounceWithCheckpoint(Checkpoint &c){
    //Safety check    
    if(nextCheckpointId != c.id){
        return;
    }
    //Handle pod data over next checkpoint
    ++nextCheckpointId;
    ++checkpointsElapsed;
    timeout = 100;
}

void Pod::Output(const class Move& move) const{

}

void Pod::UpdateValues(float x, float y, float vx, float vy, float angle, int nextCheckPointId){
    this->x = x;
    this->y = y;
    this->vx = vx;
    this->vy = vy;
    this->angle = angle;
    this->nextCheckpointId = nextCheckPointId;
}


Collision::Collision(Unit& a, Unit& b): a(a), b(b){}

Move::Move(float angle, int thrust): angle(angle), thrust(thrust){}
    
void Move::Mutate(float amplitude){
        
}

void Solution::Mutate(float amplitude){

}

void Play(Pod*const pods[], Checkpoint* checkpoints[]) {
    int podsLenght =NUM_PODS_PER_PLAYER * NUM_PLAYERS;
    for (float t = 0.0f; t <= 1.0f ; t += SIMULATION_TICK_INTERVAL) {
        //Move pods
        for(int i = 0; i < podsLenght; ++i){
            pods[i]->Move(SIMULATION_TICK_INTERVAL);            
        }

        //Check pod collisions
        for(int i = 0; i < podsLenght; ++i){

            //With desired checkpoint
            Collision* col = pods[i]->CheckCollision(*checkpoints[pods[i]->nextCheckpointId]);
            
            if(col){
                cerr << "Col a " << col->a.id << " b " << col->b.id << " t " << t <<endl;
                col->a.Bounce(col->b);

                free(col);
                col = nullptr;
            }


            //With other pods
            for(int j = i+1; j < podsLenght; ++j){
                col = pods[i]->CheckCollision(*pods[j]);
                
                if(col){
                    cerr << "Col a " << col->a.id << " b " << col->b.id << " t " << t <<endl;
                    col->a.Bounce(col->b);

                    free(col);
                    col = nullptr;
                }
            }
        }
    }

    for (int i = 0; i < podsLenght; ++i) {
        pods[i]->EndTurnCalculations();
    }
}

void Test(Pod*const pods[], Checkpoint* checkpoints[]) {

    int podsLenght =NUM_PODS_PER_PLAYER * NUM_PLAYERS;    

    for (int i = 0; i < podsLenght; ++i) {
        pods[i]->Rotate(Point(8000, 4500));
        pods[i]->Boost(100);
    }

    Play(pods, checkpoints);
}


/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
int main()
{


    int laps;
    cin >> laps; cin.ignore();

    int checkpointCount;
    cin >> checkpointCount; cin.ignore();
    
    Checkpoint* checkpoints[checkpointCount];
    for (int i = 0; i < checkpointCount; i++) {
        int checkpointX;
        int checkpointY;
        cin >> checkpointX >> checkpointY; cin.ignore();
        checkpoints[i] = new Checkpoint(checkpointX, checkpointY,i);
    }

    Pod* pods[NUM_PODS_PER_PLAYER*NUM_PLAYERS];
    for(int i = 0; i < NUM_PODS_PER_PLAYER*NUM_PLAYERS; ++i){//We init ours and enemy ones
        pods[i] = new Pod(i);
    }

    bool test = true;
    // game loop
    while (1) {

        for (int i = 0; i < NUM_PODS_PER_PLAYER; i++) {
            int x; // x position of your pod
            int y; // y position of your pod
            int vx; // x speed of your pod
            int vy; // y speed of your pod
            int angle; // angle of your pod
            int nextCheckPointId; // next check point id of your pod
            cin >> x >> y >> vx >> vy >> angle >> nextCheckPointId; cin.ignore();
            if(test){
            pods[i]->UpdateValues(x,y, vx, vy, angle, nextCheckPointId);
            }
            cerr << "Real: x " << x << " y " << y << " vx " << vx << " vy " << vy << endl;
        }

        for (int i = NUM_PODS_PER_PLAYER; i < NUM_PODS_PER_PLAYER*NUM_PLAYERS; i++) {
            int x2; // x position of the opponent's pod
            int y2; // y position of the opponent's pod
            int vx2; // x speed of the opponent's pod
            int vy2; // y speed of the opponent's pod
            int angle2; // angle of the opponent's pod
            int nextCheckPointId2; // next check point id of the opponent's pod
            cin >> x2 >> y2 >> vx2 >> vy2 >> angle2 >> nextCheckPointId2; cin.ignore();

            if(test){
            pods[i]->UpdateValues(x2, y2, vx2, vy2, angle2,  nextCheckPointId2);
            }
            cerr << "Real: x " << x2 << " y " << y2 << " vx " << vx2 << " vy " << vy2 << endl;
        }

        //test = false;

        Test(pods,checkpoints);
        
        //Display simulated ones
        for(int i = 0; i < NUM_PODS_PER_PLAYER*NUM_PLAYERS; ++i){
            Pod* currentPod = pods[i];
            cerr << "Simulation: id " << currentPod->id << " x " << currentPod->x << " y " << currentPod->y << " vx " << currentPod->vx << " vy " << currentPod->vy << endl;
        }

        // You have to output the target position
        // followed by the power (0 <= thrust <= 100)
        // i.e.: "x y thrust"
        cout << "8000 "<< "4500" << " 100" << endl;
        cout << "8000 "<< "4500" << " 100" << endl;
    }
}