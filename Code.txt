#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "cmath"

using namespace std;

#define PI 3.14159265

const int CHECKPOINT_RADIUS = 600;
const int POD_RADIUS = 400;
const int NUM_PODS_PER_PLAYER =2;
const int NUM_PLAYERS = 2;

const int MAX_MOVES_SIM = 5;

class Point{
    public:
    float x;
    float y;

    Point(float x, float y);
    float Distance2(const Point& p)const;
    float Distance(const Point& p)const;
    Point Closest(const Point& a, const Point& b)const;
};

class Unit: public Point{
    public:
    int id;
    float r;
    float vx;
    float vy;

    Unit(float x, float y,int id, float r, float vx, float vy);
    class Collision* CheckCollision(Unit& u);
    virtual void Bounce(Unit& u);
};

class Checkpoint: public Unit{
    public:
    Checkpoint(float x, float y,int id);
    virtual void Bounce(Unit& u)override;
};

class Pod: public Unit{
    public:    
    float angle;
    int nextCheckpointId;
    int checkpointsElapsed;
    int timeout;
    int turnsSinceLastShield;

    Pod(int id);
    float GetAngle(const Point& p)const;
    float DiffAngle(const Point& p)const;
    void Rotate(const Point& p);
    void Boost(int thrust);
    void Move(float t);
    void EndTurnCalculations();
    void Play(const Point& p, int thrust);
    virtual void Bounce(Unit& u) override;
    void BounceWithCheckpoint(Checkpoint& c);
    void Output(const class Move& move) const;

    void UpdateValues(float x, float y, float vx, float vy, float angle, int nextCheckPointId);
};

class Collision{
    public:
    Unit& a;
    Unit& b;
    float t;

    Collision(Unit& a, Unit& b, float t);
};

class Move{
    public:
    float angle;
    int thrust;

    Move(float angle, int thrust);
    void Mutate(float amplitude);
};


class Solution{
    public:
    Move* moves1[MAX_MOVES_SIM];
    Move* moves2[MAX_MOVES_SIM];

    void Mutate(float amplitude);
};


Point::Point(float x, float y): x(x), y(y){}

float Point::Distance2(const Point& p)const{
    return (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y);
}

float Point::Distance(const Point& p)const{
    return sqrt(Distance2(p));
}

Point Point::Closest(const Point& a, const Point& b)const{
    float da = b.y - a.y;
    float db = a.x - b.x;
    float c1 = da*a.x + db*a.y;
    float c2 = -db*x + da*y;
    float det = da*da + db*db;
    float cx = 0;
    float cy = 0;

    if (det != 0) {
        cx = (da*c1 - db*c2) / det;
        cy = (da*c2 + db*c1) / det;
    } else {
        // The point is already on the line
        cx = x;
        cy = y;
    }

    return Point(cx, cy);
} 

Unit::Unit(float x, float y,int id, float r, float vx, float vy):Point(x, y), id(id), r(r), vx(vx), vy(vy){}

Collision* Unit::CheckCollision(Unit& u){
    // Square of the distance
    float dist = Distance2(u);

    // Sum of the radii squared
    float sr = (r + u.r)*(r + u.r);

    // We take everything squared to avoid calling sqrt uselessly. It is better for performances
    if (dist < sr) {
        // Objects are already touching each other. We have an immediate collision.
        return new Collision(*this, u, 0.0);
    }

    // Optimisation. Objects with the same speed will never collide
    if (vx == u.vx && vy == u.vy) {
        return nullptr;
    }

    // We place ourselves in the reference frame of u. u is therefore stationary and is at (0,0)
    float relativeX = x - u.x;
    float relativeY = y - u.y;
    Point myp = Point(relativeY, relativeX);
    float relativeVx = vx - u.vx;
    float relativeVy = vy - u.vy;
    Point up = Point(0, 0);
    // We look for the closest point to u (which is in (0,0)) on the line described by our speed vector
    Point p = up.Closest(myp, Point(relativeX + relativeVx, relativeY + relativeVy));
    // Square of the distance between u and the closest point to u on the line described by our speed vector
    float pdist = up.Distance2(p);

    // Square of the distance between us and that point
    float mypdist = myp.Distance2(p);
    // If the distance between u and this line is less than the sum of the radii, there might be a collision
    if (pdist < sr) {
     // Our speed on the line
        float length = sqrt(relativeVx*relativeVx + relativeVy*relativeVy);

        // We move along the line to find the point of impact
        float backdist = sqrt(sr - pdist);
        p.x = p.x - backdist * (relativeVx / length);
        p.y = p.y - backdist * (relativeVy / length);
        // If the point is now further away it means we are not going the right way, therefore the collision won't happen
        if (myp.Distance2(p) > mypdist) {
            return nullptr;
        }

        pdist = p.Distance(myp);

        // The point of impact is further than what we can travel in one turn
        if (pdist > length) {
            return nullptr;
        }

        // Time needed to reach the impact point
        float t = pdist / length;

        return new Collision(*this, u, t);
    }

    return nullptr;
}

//Will be overriden on children
void Unit::Bounce(Unit& u){}

Checkpoint::Checkpoint(float x, float y, int id): Unit(x,y,id,CHECKPOINT_RADIUS,0,0){}

void Checkpoint::Bounce(Unit& u){}

Pod::Pod(int id):Unit(0,0,id,POD_RADIUS,0,0),angle(0.0f),nextCheckpointId(0),timeout(100),turnsSinceLastShield(4){}

float Pod::GetAngle(const Point& p)const{
    float d = Distance(p);
    float dx = (p.x - x) / d;
    float dy = (p.y - y) / d;

    // Simple trigonometry. We multiply by 180.0 / PI to convert radiants to degrees.
    float a = acos(dx) * 180.0 / PI;

    // If the point I want is below me, I have to shift the angle for it to be correct
    if (dy < 0) {
        a = 360.0 - a;
    }

    return a;
}

float Pod::DiffAngle(const Point& p)const{
    float a = GetAngle(p);

    // To know whether we should turn clockwise or not we look at the two ways and keep the smallest
    // The ternary operators replace the use of a modulo operator which would be slower
    float right = angle <= a ? a - angle : 360.0 - angle + a;
    float left = angle >= a ? angle - a : angle + 360.0 - a;

    if (right < left) {
        return right;
    } else {
        // We return a negative angle if we must rotate to left
        return -left;
    }
}

void Pod::Rotate(const Point& p){
    float a = DiffAngle(p);

    // Can't turn by more than 18° in one turn
    if (a > 18.0) {
        a = 18.0;
    } else if (a < -18.0) {
        a = -18.0;
    }

    angle += a;

    // The % operator is slow. If we can avoid it, it's better.
    if (angle >= 360.0) {
        angle = angle - 360.0;
    } else if (angle < 0.0) {
        angle += 360.0;
    }
}

void Pod::Boost(int thrust){
    // Don't forget that a pod which has activated its shield cannot accelerate for 3 turns
    if (turnsSinceLastShield <= 3) {
        return;
    }

    // Conversion of the angle to radiants
    float ra = angle * PI / 180.0;

    // Trigonometry
    vx += cos(ra) * thrust;
    vy += sin(ra) * thrust;
}

void Pod::Move(float t){
    x += vx * t;
    y += vy * t;
}

void Pod::EndTurnCalculations(){
    x = round(x);
    y = round(y);
    vx = static_cast<int>(vx * 0.85);//Truncate
    vy = static_cast<int>(vy * 0.85);//Truncate

    //This can be a problem if the program would be infinite, but as it only works for a small number of turns, it would never get overflowed
    ++turnsSinceLastShield;

    // Don't forget that the timeout goes down by 1 each turn. It is reset to 100 when you pass a checkpoint
    timeout -= 1;
}

void Pod::Play(const Point& p, int thrust){
    Rotate(p);
    Boost(thrust);
    Move(1.0);
    EndTurnCalculations();
}

void Pod::Bounce(Unit& u){
    if (Checkpoint* c = dynamic_cast<Checkpoint*>(&u)) {  
        // Collision with a checkpoint
        BounceWithCheckpoint(*c);
    } else if(Pod* pod = dynamic_cast<Pod*>(&u)) {
        // If a pod has its shield active its mass is 10 otherwise it's 1
        float m1 = turnsSinceLastShield == 0 ? 10 : 1;
        float m2 = pod->turnsSinceLastShield == 0 ? 10 : 1;
        float mcoeff = (m1 + m2) / (m1 * m2);

        float nx = x - pod->x;
        float ny = y - pod->y;

        // Square of the distance between the 2 pods. This value could be hardcoded because it is always 800²
        float nxnysquare = nx*nx + ny*ny;

        float dvx = vx - pod->vx;
        float dvy = vy - pod->vy;

        // fx and fy are the components of the impact vector. product is just there for optimisation purposes
        float product = nx*dvx + ny*dvy;
        float fx = (nx * product) / (nxnysquare * mcoeff);
        float fy = (ny * product) / (nxnysquare * mcoeff);

        // We apply the impact vector once
        vx -= fx / m1;
        vy -= fy / m1;
        pod->vx += fx / m2;
        pod->vy += fy / m2;

        // If the norm of the impact vector is less than 120, we normalize it to 120
        float impulse = sqrt(fx*fx + fy*fy);
        if (impulse < 120.0) {
            fx = fx * 120.0 / impulse;
            fy = fy * 120.0 / impulse;
        }

        // We apply the impact vector a second time
        vx -= fx / m1;
        vy -= fy / m1;
        pod->vx += fx / m2;
        pod->vy += fy / m2;

        // This is one of the rare places where a Vector class would have made the code more readable.
        // But this place is called so often that I can't pay a performance price to make it more readable.
    }
}

void Pod::BounceWithCheckpoint(Checkpoint &c){
    //Handle pod data over next checkpoint
    ++nextCheckpointId;
    ++checkpointsElapsed;
    timeout = 100;
}

void Pod::Output(const class Move& move) const{

}

void Pod::UpdateValues(float x, float y, float vx, float vy, float angle, int nextCheckPointId){
    this->x = x;
    this->y = y;
    this->vx = vx;
    this->vy = vy;
    this->angle = angle;
    this->nextCheckpointId = nextCheckPointId;
}


Collision::Collision(Unit& a, Unit& b, float t): a(a), b(b), t(t){}

Move::Move(float angle, int thrust): angle(angle), thrust(thrust){}
    
void Move::Mutate(float amplitude){
        
}

void Solution::Mutate(float amplitude){

}

void Play(Pod*const pods[], Checkpoint* checkpoints[]) {
    // This tracks the time during the turn. The goal is to reach 1.0
    float t = 0.0;

    int podsLenght =NUM_PODS_PER_PLAYER * NUM_PLAYERS;
    //Collisions per t
    vector<Collision*> lastLoopCollisions;
    while (t < 1.0) {
        Collision* firstCollision = nullptr;

        // We look for all the collisions that are going to occur during the turn
        for (int i = 0; i < podsLenght; ++i) {
            // Collision with another pod?
            for (int j = i + 1; j < podsLenght; ++j) {
                Collision* col = pods[i]->CheckCollision(*pods[j]);

                for(int k = 0; k < lastLoopCollisions.size(); ++k){
                    Collision* lastLoopCollision = lastLoopCollisions[k];
                    if(lastLoopCollision && col){
                        Checkpoint* checkpointCheck = dynamic_cast<Checkpoint*>(&lastLoopCollision->b);
                        //If the collision is the same than last loop, we skip it
                        //We need to check if its checkpint as ID are from 0-checkpoints and 0-Pods, so can't rely on that
                        if(!checkpointCheck && &lastLoopCollision->a == &col->a && &lastLoopCollision->b == &col->b){
                            free(col);
                            col = nullptr;
                            continue;
                        }
                    }
                }

                if(col != nullptr){
                    cerr << "col t" << col->t << " a " << col->a.id << " b " << col->b.id << endl;
                }

                // If the collision occurs earlier than the one we currently have we keep it
                if (col != nullptr && col->t + t < 1.0 && (firstCollision == nullptr || col->t < firstCollision->t)) {
                    free(firstCollision);
                    firstCollision = col;
                }else{
                    free(col);
                    col = nullptr;
                }
            }

            // Collision with another checkpoint?
            // It is unnecessary to check all checkpoints here. We only test the pod's next checkpoint.
            // We could look for the collisions of the pod with all the checkpoints, but if such a collision happens it wouldn't impact the game in any way
            Collision* col = pods[i]->CheckCollision(*checkpoints[pods[i]->nextCheckpointId]);

            if(col != nullptr){
                cerr << "col t" << col->t << " a " << col->a.id << " b " << col->b.id << endl;
            }

            // If the collision happens earlier than the current one we keep it
            if (col != nullptr && col->t + t < 1.0 && (firstCollision == nullptr || col->t < firstCollision->t)) {
                free(firstCollision);
                firstCollision = col;
            }else{
                free(col);
                col = nullptr;
            }
        }

        if (firstCollision == nullptr) {
            // No collision, we can move the pods until the end of the turn
            for (int i = 0; i < podsLenght; ++i) {
                pods[i]->Move(1.0 - t);
            }

            // End of the turn
            t = 1.0;
        } else {
            // Move the pods to reach the time `t` of the collision
            for (int i = 0; i < podsLenght; ++i) {
                pods[i]->Move(firstCollision->t);
            }

            // Play out the collision
            firstCollision->a.Bounce(firstCollision->b);

            t += firstCollision->t;

            //If we are moving to a new t we can clean current loop collisions
            if(!lastLoopCollisions.empty() && firstCollision->t != lastLoopCollisions[0]->t){
                for(int i = 0; i < lastLoopCollisions.size(); ++i){
                    free(lastLoopCollisions[i]);
                }
                lastLoopCollisions.clear();
            }

            lastLoopCollisions.push_back(firstCollision);
        }
    }

    //Clear before finish
    for(int i = 0; i < lastLoopCollisions.size(); ++i){
        free(lastLoopCollisions[i]);
    }
    lastLoopCollisions.clear();

    for (int i = 0; i < podsLenght; ++i) {
        pods[i]->EndTurnCalculations();
    }
}

void Test(Pod*const pods[], Checkpoint* checkpoints[]) {

    int podsLenght =NUM_PODS_PER_PLAYER * NUM_PLAYERS;    

    for (int i = 0; i < podsLenght; ++i) {
        pods[i]->Rotate(Point(8000, 4500));
        pods[i]->Boost(100);
    }

    Play(pods, checkpoints);
}


/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
int main()
{


    int laps;
    cin >> laps; cin.ignore();

    int checkpointCount;
    cin >> checkpointCount; cin.ignore();
    
    Checkpoint* checkpoints[checkpointCount];
    for (int i = 0; i < checkpointCount; i++) {
        int checkpointX;
        int checkpointY;
        cin >> checkpointX >> checkpointY; cin.ignore();
        checkpoints[i] = new Checkpoint(checkpointX, checkpointY,i);
    }

    Pod* pods[NUM_PODS_PER_PLAYER*NUM_PLAYERS];
    for(int i = 0; i < NUM_PODS_PER_PLAYER*NUM_PLAYERS; ++i){//We init ours and enemy ones
        pods[i] = new Pod(i);
    }

    bool test = true;
    // game loop
    while (1) {

        for (int i = 0; i < NUM_PODS_PER_PLAYER; i++) {
            int x; // x position of your pod
            int y; // y position of your pod
            int vx; // x speed of your pod
            int vy; // y speed of your pod
            int angle; // angle of your pod
            int nextCheckPointId; // next check point id of your pod
            cin >> x >> y >> vx >> vy >> angle >> nextCheckPointId; cin.ignore();
            if(test){
            pods[i]->UpdateValues(x,y, vx, vy, angle, nextCheckPointId);
            }
            cerr << "Real: x " << x << " y " << y << " vx " << vx << " vy " << vy << endl;
        }

        for (int i = NUM_PODS_PER_PLAYER; i < NUM_PODS_PER_PLAYER*NUM_PLAYERS; i++) {
            int x2; // x position of the opponent's pod
            int y2; // y position of the opponent's pod
            int vx2; // x speed of the opponent's pod
            int vy2; // y speed of the opponent's pod
            int angle2; // angle of the opponent's pod
            int nextCheckPointId2; // next check point id of the opponent's pod
            cin >> x2 >> y2 >> vx2 >> vy2 >> angle2 >> nextCheckPointId2; cin.ignore();

            if(test){
            pods[i]->UpdateValues(x2, y2, vx2, vy2, angle2,  nextCheckPointId2);
            }
            cerr << "Real: x " << x2 << " y " << y2 << " vx " << vx2 << " vy " << vy2 << endl;
        }

        //test = false;

        Test(pods,checkpoints);
        
        //Display simulated ones
        for(int i = 0; i < NUM_PODS_PER_PLAYER*NUM_PLAYERS; ++i){
            Pod* currentPod = pods[i];
            cerr << "Simulation: id " << currentPod->id << " x " << currentPod->x << " y " << currentPod->y << " vx " << currentPod->vx << " vy " << currentPod->vy << endl;
        }

        // You have to output the target position
        // followed by the power (0 <= thrust <= 100)
        // i.e.: "x y thrust"
        cout << "8000 "<< "4500" << " 100" << endl;
        cout << "8000 "<< "4500" << " 100" << endl;
    }
}